<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FAAST: Reference Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FAAST
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">index</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Reference Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>FAAST offers an intuitive object-oriented interface to handle finite fields and their extensions. The three main types you will use are <a class="el" href="classFAAST_1_1Field.html" title="A finite field.">Field</a>, <a class="el" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">FieldElement</a> and <a class="el" href="classFAAST_1_1FieldPolynomial.html" title="An polynomial with coefficients over a finite field.">FieldPolynomial</a>, which are described in the section <a class="el" href="Refman.html#Refman_Field">Finite Field Arithmetics</a>.</p>
<p>FAAST adds some genericity on top of the traditional <code><a class="el" href="References.html#NTL">NTL</a></code> architecture, one of its most prominent features is the mechanism of <a class="el" href="Refman.html#Refman_Infrastructure">Infrastructures</a> which uses C++ templates to let you choose statically (at compile-time) which set of <code><a class="el" href="References.html#NTL">NTL</a></code> algorithms use.</p>
<p>All in all, the goal of FAAST is to represent <a class="el" href="Refman.html#Field_lattices">Lattices of fields</a> and give algorithms to work into them. For the moment FAAST is limited to some special types of lattices arising from Artin-Schreier towers. See <a class="el" href="Refman.html#Field_lattices">Lattices of fields</a> for more details.</p>
<h1><a class="anchor" id="Refman_Field"></a>
Finite Field Arithmetics</h1>
<p>This module contains three types, namely <a class="el" href="classFAAST_1_1Field.html" title="A finite field.">FAAST::Field</a>, <a class="el" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">FAAST::FieldElement</a> and <a class="el" href="classFAAST_1_1FieldPolynomial.html" title="An polynomial with coefficients over a finite field.">FAAST::FieldPolynomial</a>, which represent, respectively, finite fields, elements of finite fields and polynomials with coefficient over finite fields.With some notable exception (see <a class="el" href="classFAAST_1_1FieldElement.html#a8503d1b29ed7a86a9237ad5d5db663a2">FieldElement()</a> and <a class="el" href="classFAAST_1_1FieldPolynomial.html#afab4e48e2a24610f579f5bcf3517f31b">FieldPolynomial()</a>), each <a class="el" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">FAAST::FieldElement</a> and <a class="el" href="classFAAST_1_1FieldPolynomial.html" title="An polynomial with coefficients over a finite field.">FAAST::FieldPolynomial</a> belongs to a <a class="el" href="classFAAST_1_1Field.html" title="A finite field.">FAAST::Field</a> object called its <em>parent</em> <em>field</em>. Elements (and polynomials) having the same parent field can be combined (added, multiplied, etc.) freely, while limitations apply for combining elements belonging to two different fields; see <a class="el" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">FAAST::FieldElement</a> and <a class="el" href="classFAAST_1_1FieldPolynomial.html" title="An polynomial with coefficients over a finite field.">FAAST::FieldPolynomial</a>.Elements (and polynomials) can be moved from one field to another when a morphism is known; see <a class="el" href="Refman.html#Field_lattices">Lattices of fields</a>. </p>
<p>See the module <a class="el" href="group__Fields.html">Finite Field Arithmetics</a> for the list of methods and functions.</p>
<h1><a class="anchor" id="Refman_Infrastructure"></a>
Infrastructures</h1>
<p><code><a class="el" href="References.html#NTL">NTL</a></code> provides three different ways of representing modular integers:</p>
<ul>
<li><code>zz_p</code> is a class representing modular integers with word-sized modulus,</li>
<li><code>ZZ_p</code> is a class representing modular integers with arbitrary sized modulus,</li>
<li><code>GF2</code> is a class representing integers modulo 2.</li>
</ul>
To each of these types corresponds a whole family of types (<code>ZZ_p_X</code>, <code>GF2_E</code>, etc.) representing polynomials with modular coefficients, modular polynomials with modular coefficients, etc. The actual algorithms implementing arithmetics for such types vary and affect remarkably the performances of FAAST. See the <code><a class="el" href="References.html#NTL">NTL</a></code> manual for more details.<a class="el" href="group__Infrastructures.html">Infrastructures</a> are collections (<code>struct</code> 's) of types providing genericity over <code><a class="el" href="References.html#NTL">NTL</a></code> types. They provide an unique set of names to abstract from the implementation details of the three NTL families <code>ZZ_p*</code>, <code>zz_p*</code> and <code>GF2*</code>. You must provide an Infrastructure as template parameter to the types and most of the functions of FAAST. This parameter tells FAAST which of the three <code><a class="el" href="References.html#NTL">NTL</a></code> families it should use to perform modular arithmetics.Here's an example of how to use the infrastructure <a class="el" href="structFAAST_1_1zz__p__Algebra.html" title="The infrastructure corresponding to zz_p* types.">FAAST::zz_p_Algebra</a>. First some <code>typedef</code> 's to save typing:  <div class="fragment"><div class="line"><span class="keyword">typedef</span> Field&lt;zz_p_Algebra&gt;  <a class="code" href="classFAAST_1_1Field.html" title="A finite field.">gfp</a>;</div>
<div class="line"><span class="keyword">typedef</span> FieldElement&lt;zz_p_Algebra&gt;  <a class="code" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">gfp_E</a>;</div>
<div class="line"><span class="keyword">typedef</span> FieldPolynomial&lt;zz_p_Algebra&gt;  <a class="code" href="classFAAST_1_1FieldPolynomial.html" title="An polynomial with coefficients over a finite field.">gfp_X</a>;</div>
</div><!-- fragment --> Then define some parameters (characteristic, degree, etc.), notice the use of <a class="el" href="classFAAST_1_1Field.html#a70caed6572b9e14693a97c708ed2f20a" title="A link to the Infrastructures Infrastructure.">FAAST::Field::Infrastructure</a> as an alias for <a class="el" href="structFAAST_1_1zz__p__Algebra.html" title="The infrastructure corresponding to zz_p* types.">FAAST::zz_p_Algebra</a> (useful if you later change your mind about the Infrastructure): <div class="fragment"><div class="line">    gfp::Infrastructure::BigInt p;</div>
<div class="line">    <span class="keywordtype">long</span> d, l;</div>
</div><!-- fragment --> Finally create a finite field: <div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="classFAAST_1_1Field.html" title="A finite field.">gfp</a>* K = &amp;(<a class="code" href="classFAAST_1_1Field.html#ae2b7263efdfe777aebe63c387107afcb" title="Default instantiator, builds a field from NTL&#39;s context.">gfp::createField</a>(p,d));</div>
</div><!-- fragment -->If you are wondering which Infrastructure you should use, then use <a class="el" href="structFAAST_1_1zz__p__Algebra.html" title="The infrastructure corresponding to zz_p* types.">FAAST::zz_p_Algebra</a>, as it is quite flexible and way faster than <a class="el" href="structFAAST_1_1ZZ__p__Algebra.html" title="The infrastructure corresponding to ZZ_p* types.">FAAST::ZZ_p_Algebra</a>.If you plan to construct fields with huge characteristics (larger than the largest <code>long</code>), then you should opt for <a class="el" href="structFAAST_1_1ZZ__p__Algebra.html" title="The infrastructure corresponding to ZZ_p* types.">FAAST::ZZ_p_Algebra</a>; notice however that FAAST does not let you build Artin-Schreier extensions in characteristics greater than the greatest <code>long</code>, so you will probably miss its most exciting features.Finally, if you only work in characteristic 2 and care about performance, you should consider compiling <code><a class="el" href="References.html#NTL">NTL</a></code> with the <code><a class="el" href="References.html#gf2x">gf2x</a></code> library and using <a class="el" href="structFAAST_1_1GF2__Algebra.html" title="The infrastructure corresponding to GF2* types.">FAAST::GF2_Algebra</a> as Infrastructure. If you don't use the <code><a class="el" href="References.html#gf2x">gf2x</a></code> library, then <a class="el" href="structFAAST_1_1GF2__Algebra.html" title="The infrastructure corresponding to GF2* types.">FAAST::GF2_Algebra</a> will only be interesting for moderate field cardinalities, but it will give the pace up to <a class="el" href="structFAAST_1_1zz__p__Algebra.html" title="The infrastructure corresponding to zz_p* types.">FAAST::zz_p_Algebra</a> for huge fields. </p>
<p>See the module <a class="el" href="group__Infrastructures.html">Infrastructures</a> for more details.</p>
<h1><a class="anchor" id="Field_lattices"></a>
Lattices of fields</h1>
<p>The most exciting feature of FAAST is its ability to deal with field extension and keep track of morphisms. This ability is limited to Artin-Schreier towers as described in [<a class="el" href="References.html#ISSAC">DFS&#160;'09</a>] and [<a class="el" href="References.html#Cou00">Couveignes&#160;'00</a>] and gives rise to lattices of a special form; we call them <em>stem</em> <em>lattices</em>.</p>
<p>For the rest of this section <em>p</em> will be the characteristic of our fields. Remind that an Artin-Schreier extension is a field extension of degree <em>p</em> generated by an irreducible polynomial of the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ X^p - X - a\mathrm{.} \]" src="form_16.png"/>
</p>
<p>The simplest lattice is the lattice formed by a single field. Finite fields of arbitrary cardinality can be built through the static instantiators <a class="el" href="classFAAST_1_1Field.html#ae2b7263efdfe777aebe63c387107afcb" title="Default instantiator, builds a field from NTL&#39;s context.">Field::createField()</a>. Suppose you build the field with <em>p</em> elements F<sub>p</sub> then the resulting lattice looks like </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[F_p\]" src="form_17.png"/>
</p>
<p>When you build non-prime fields, the prime subfield is automatically constructed. Suppose you build a field named <b>K</b><sub>0</sub>, then the resulting lattice looks like </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\xymatrix{ \mathbf{K}_0 \ar@{-}[d]\\ F_p }\]" src="form_18.png"/>
</p>
<p>Now, to add fields to a lattice there is two methods, namely <a class="el" href="classFAAST_1_1Field.html#a9a03bb939246ee9548c251a6541ce3eb" title="Build a primitive extension of degree p as in [DFS &#39;09, Section 3].">Field::ArtinSchreierExtension() const</a> and <a class="el" href="classFAAST_1_1Field.html#a85dbb6eb1385122cc8b4eaa96bfb0f73" title="Build the splitting field of the polynomial  as in [DFS &#39;09, Section 6].">Field::ArtinSchreierExtension(const FieldElement&amp;) const</a>. Both create an Artin-Schreier extension, but they differ in the way the extension is created. The former method chooses a default irreducible Artin-Schreier polynomial such that the generated Artin-Schreier extension is <em>primitive</em> in the sense of [<a class="el" href="References.html#ISSAC">DFS&#160;'09</a>, Section 3]. The resulting lattice is then </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\xymatrix{ \mathbf{K}_1\ar@{-}[d]^p\\ \mathbf{K}_0 \ar@{-}[d]\\ F_p }\]" src="form_19.png"/>
</p>
<p> The latter method constructs the splitting fields of the polynomial <img class="formulaInl" alt="$ X^p - X - \mathtt{e} $" src="form_20.png"/> where <code>e</code> is the <a class="el" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">FieldElement</a> given as a parameter. Assuming that the polynomial is irreducible, it constructs a primitive extension using <a class="el" href="classFAAST_1_1Field.html#a9a03bb939246ee9548c251a6541ce3eb" title="Build a primitive extension of degree p as in [DFS &#39;09, Section 3].">Field::ArtinSchreierExtension() const </a>and then uses the isomorphism algorithm of [<a class="el" href="References.html#Cou00">Couveignes&#160;'00</a>] to establish an isomorphism between the primitive field and the splitting field. So for example a call to </p>
<div class="fragment"><div class="line">K0.ArtinSchreierExtension(e);</div>
</div><!-- fragment --><p> would generate a lattice </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\xymatrix{ \mathbf{K}_1\ar@{-}[d]^p &amp; \mathbf{L}_1\ar@{~}[l]\\ \mathbf{K}_0 \ar@{-}[d]\\ F_p }\]" src="form_21.png"/>
</p>
<p> where <b>K</b><sub>1</sub> is the primitive extension and <b>U</b><sub>1</sub> is the field generated by <img class="formulaInl" alt="$X^p - X - \mathtt{e}$" src="form_22.png"/>.</p>
<p>All the objects of type <a class="el" href="classFAAST_1_1Field.html" title="A finite field.">Field</a> are persistent: once they are created they are never destroyed. So, even if you don't hold a reference to <b>K</b><sub>1</sub>, another call to </p>
<div class="fragment"><div class="line">K0.ArtinSchreierExtension(e2);</div>
</div><!-- fragment --><p> will not create a new primitive field, it will use <b>K</b><sub>1</sub> instead. The resulting lattice would be </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\xymatrix{ \mathbf{M}_1\ar@{~}[r] &amp; \mathbf{K}_1\ar@{-}[d]^p &amp; \mathbf{L}_1\ar@{~}[l]\\ &amp; \mathbf{K}_0 \ar@{-}[d]\\ &amp; F_p }\]" src="form_23.png"/>
</p>
<p>By repeatedly mixing calls to the two methods, one ends up with lattices of the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\xymatrix{ \mathbf{W}_n\ar@{~}[r] &amp; \mathbf{K}_n\ar@{--}[dd] &amp; \mathbf{Z}_n\ar@{~}[l]\\ \\ \mathbf{U}_2\ar@{~}[r] &amp; \mathbf{K}_2\ar@{-}[d]^p &amp; \mathbf{V}_2\ar@{~}[l]\\ \mathbf{M}_1\ar@{~}[r] &amp; \mathbf{K}_1\ar@{-}[d]^p &amp; \mathbf{L}_1\ar@{~}[l]\\ &amp; \mathbf{K}_0 \ar@{-}[d]\\ &amp; F_p }\]" src="form_24.png"/>
</p>
<p>Now the reason why we call this a <em>stem</em> <em>lattice</em> should be clear. In the middle there's the <em>primitive</em> <em>tower</em> (<b>K</b><sub>0</sub>, <b>K</b><sub>1</sub>, ..., <b>K</b><sub>n</sub>), in the sense of [<a class="el" href="References.html#ISSAC">DFS&#160;'09</a>, Section 3], which we call <em>the</em> <em>stem</em>. The stem is organized in levels, each level being an extension of degree <em>p</em> over the lower one (with the only possible exception of the extension <b>K</b><sub>0</sub>/F<sub>p</sub>). At each level, a set of fields all isomorphic to that level forms the <em>spurs</em>.</p>
<p>The methods <a class="el" href="classFAAST_1_1Field.html#a2f9151b6ebdf59478bb8a840a3c5386a" title="The immediate subfield in the primitive tower.">Field::subField()</a>, <a class="el" href="classFAAST_1_1Field.html#a872ca3872d812bccfe48dd94b2e3348e" title="The immediate overfield in the primitive tower.">Field::overField()</a>, <a class="el" href="classFAAST_1_1Field.html#a3d4b731ae1f8c495626371709015a35c" title="The base field of the Artin-Schreier tower.">Field::baseField()</a>, <a class="el" href="classFAAST_1_1Field.html#a04ca553af2b57d63ed43cba96a60d32d" title="The prime field Fp of this field.">Field::primeField()</a> and <a class="el" href="classFAAST_1_1Field.html#aea87cd55abed5aaf90f62070ff7f012e" title="The field on the primitive tower isomorphic to this field.">Field::stemField()</a> let you navigate field lattices.</p>
<p>Coercion operators (see <a class="el" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">FieldElement</a> and <a class="el" href="classFAAST_1_1FieldPolynomial.html" title="An polynomial with coefficients over a finite field.">FieldPolynomial</a>) let you move elements from one field to the other, provided that the element belongs to both fields. So for example you can move elements from <b>K</b><sub>0</sub> or <b>M</b><sub>1</sub> to <b>L</b><sub>1</sub>, but it will not always be possible to move an element from <b>K</b><sub>2</sub> to <b>K</b><sub>1</sub>. For example, coercion from <b>K</b><sub>0</sub> to <b>K</b><sub>1</sub> is as easy as </p>
<div class="fragment"><div class="line">e0 = K0.random();</div>
<div class="line">e1 = e0 &gt;&gt; K1;</div>
</div><!-- fragment --><p> In case a coercion is not possible, an <a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a> is issued.</p>
<p>Another way of moving around in field lattices is to use the vector space morphisms between the levels of the lattice. The functions <a class="el" href="classFAAST_1_1FieldElement.html#acc1e83d603a387d3a875f52ca2842e0b" title="Convert e from the internal (univariate) representation to the bivariate representation over the imme...">pushDown()</a> and <a class="el" href="classFAAST_1_1FieldElement.html#a8578eb66961b7bbc23c9887eab174cea" title="Convert v from the bivariate representation over the immediate subfield in the primitive tower (the s...">liftUp()</a> let you express the morphism between two adjacent levels of the stem, while <a class="el" href="classFAAST_1_1Field.html#ac35d44bfcaff36077b66015bfbea15aa" title="Convert the univariate representation of e to the multivariate representation over this field...">Field::toBivariate()</a> and <a class="el" href="classFAAST_1_1Field.html#a6020e3f1cf26bbf536152ff85beb37b6" title="Convert the multivariate representation of v to the univariate representation of this field...">Field::toUnivariate()</a> let you express the morphisms between to arbitrary spurs in two adjacent levels. Notice that there is no need to know what the order of the calls to <a class="el" href="classFAAST_1_1Field.html#a9a03bb939246ee9548c251a6541ce3eb" title="Build a primitive extension of degree p as in [DFS &#39;09, Section 3].">Field::ArtinSchreierExtension()</a> was in order to apply these methods: any field of a level can be considered as an Artin-Schreier extension over any other field in the lower level.</p>
<h1><a class="anchor" id="Refman_Exception"></a>
Exceptions</h1>
<p>See the <a class="el" href="group__Exceptions.html">Exceptions</a> module for a list of all the exceptions thrown by methods and functions of this library. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 3 2013 20:49:49 for FAAST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
