<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FAAST: FAAST::FieldElement&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FAAST
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>FAAST</b></li><li class="navelem"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">FAAST::FieldElement&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Fields.html">Finite Field Arithmetics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An element of a finite field.  
 <a href="classFAAST_1_1FieldElement.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a8503d1b29ed7a86a9237ad5d5db663a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a8503d1b29ed7a86a9237ad5d5db663a2">FieldElement</a> ()  throw ()</td></tr>
<tr class="memdesc:a8503d1b29ed7a86a9237ad5d5db663a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the special 0 element.  <a href="#a8503d1b29ed7a86a9237ad5d5db663a2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Properties</div></td></tr>
<tr class="memitem:a78120b7dff3255ead926f22a466fc438"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent</a> () const   throw (UndefinedFieldException)</td></tr>
<tr class="memdesc:a78120b7dff3255ead926f22a466fc438"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <em>parent</em> <em>field</em>.  <a href="#a78120b7dff3255ead926f22a466fc438"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Copy</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can copy elements using assignment. </p>
</div></td></tr>
<tr class="memitem:afe3abc9d09bd30a3576d77ed0209db1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe3abc9d09bd30a3576d77ed0209db1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldElement</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e)  throw ()</td></tr>
<tr class="memitem:adfad9ba8baa50fc9555745a2ff5256ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfad9ba8baa50fc9555745a2ff5256ee"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e)  throw ()</td></tr>
<tr class="memitem:afbaf9194f2688bb675c0916211aacff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#afbaf9194f2688bb675c0916211aacff4">operator=</a> (const BigInt &amp;i)  throw (UndefinedFieldException)</td></tr>
<tr class="memdesc:afbaf9194f2688bb675c0916211aacff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a scalar value to this element.  <a href="#afbaf9194f2688bb675c0916211aacff4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Binary operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All binary operators throw a <a class="el" href="classFAAST_1_1NotInSameFieldException.html" title="The two elements do not belong to the same field.">NotInSameFieldException</a> if neither of this two conditions is satisfied:</p>
<ul>
<li>the two operands have the same <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>,</li>
<li>the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of one operand is the prime field of the other's. </li>
</ul>
</div></td></tr>
<tr class="memitem:a3f5e3e1ad93ad384734724948f13e2d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f5e3e1ad93ad384734724948f13e2d4"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e) const   throw (NotInSameFieldException)</td></tr>
<tr class="memitem:aeaab44aebe840ae25cd8192ca453bcd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaab44aebe840ae25cd8192ca453bcd0"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e) const   throw (NotInSameFieldException)</td></tr>
<tr class="memitem:adcf7cf66f38d8f751209fdce4dd4db1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcf7cf66f38d8f751209fdce4dd4db1f"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e) const   throw (NotInSameFieldException)</td></tr>
<tr class="memitem:a6ddee3f243a17490083149ad5b639ecc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ddee3f243a17490083149ad5b639ecc"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e) const   throw (NotInSameFieldException, DivisionByZeroException)</td></tr>
<tr class="memitem:a15a187f4402dd3838359d9773acd805b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15a187f4402dd3838359d9773acd805b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;)  throw (NotInSameFieldException)</td></tr>
<tr class="memitem:a243080e107b89a40a6ab41ac31a48d0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a243080e107b89a40a6ab41ac31a48d0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;)  throw (NotInSameFieldException)</td></tr>
<tr class="memitem:a435a7276289d32d46759783aaff84b08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a435a7276289d32d46759783aaff84b08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;)  throw (NotInSameFieldException)</td></tr>
<tr class="memitem:ac7f38662c61c05bbb26d117951cc0f93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7f38662c61c05bbb26d117951cc0f93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;)  throw (NotInSameFieldException, DivisionByZeroException)</td></tr>
<tr class="memitem:a0a95ec858eeb8e168cc3a3d15c9a2fa7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a95ec858eeb8e168cc3a3d15c9a2fa7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a0a95ec858eeb8e168cc3a3d15c9a2fa7">sum</a> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;a, const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;b)  throw (NotInSameFieldException)</td></tr>
<tr class="memdesc:a0a95ec858eeb8e168cc3a3d15c9a2fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <em>a</em> + <em>b</em> in this element. <br/></td></tr>
<tr class="memitem:a998bd6852a8316f51dcb5750ab141ce0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a998bd6852a8316f51dcb5750ab141ce0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a998bd6852a8316f51dcb5750ab141ce0">difference</a> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;a, const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;b)  throw (NotInSameFieldException)</td></tr>
<tr class="memdesc:a998bd6852a8316f51dcb5750ab141ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <em>a</em> - <em>b</em> in this element. <br/></td></tr>
<tr class="memitem:a4459ff606d073b06b4a37630b9578348"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4459ff606d073b06b4a37630b9578348"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a4459ff606d073b06b4a37630b9578348">product</a> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;a, const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;b)  throw (NotInSameFieldException)</td></tr>
<tr class="memdesc:a4459ff606d073b06b4a37630b9578348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <em>a</em> * <em>b</em> in this element. <br/></td></tr>
<tr class="memitem:a06df7ec9e7e3b4515d9ed2eef3869c84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06df7ec9e7e3b4515d9ed2eef3869c84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a06df7ec9e7e3b4515d9ed2eef3869c84">division</a> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;a, const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;b)  throw (NotInSameFieldException, DivisionByZeroException)</td></tr>
<tr class="memdesc:a06df7ec9e7e3b4515d9ed2eef3869c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <em>a</em> / <em>b</em> in this element. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Unary operators</div></td></tr>
<tr class="memitem:af93a7bd2cc816867c3f55117a84e1beb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af93a7bd2cc816867c3f55117a84e1beb"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#af93a7bd2cc816867c3f55117a84e1beb">operator-</a> () const   throw ()</td></tr>
<tr class="memdesc:af93a7bd2cc816867c3f55117a84e1beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additive inverse. <br/></td></tr>
<tr class="memitem:a6c15a010190f4a0f6195691847a4d20d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c15a010190f4a0f6195691847a4d20d"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a6c15a010190f4a0f6195691847a4d20d">inv</a> () const   throw (DivisionByZeroException)</td></tr>
<tr class="memdesc:a6c15a010190f4a0f6195691847a4d20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplicative inverse. <br/></td></tr>
<tr class="memitem:a50c2a95cd43c79e70a1463898f48fe99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50c2a95cd43c79e70a1463898f48fe99"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a50c2a95cd43c79e70a1463898f48fe99">operator^</a> (const ZZ &amp;i) const   throw ()</td></tr>
<tr class="memdesc:a50c2a95cd43c79e70a1463898f48fe99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power. <br/></td></tr>
<tr class="memitem:a6dc18cdbf108e2414b5fd6d7dbcbe7c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dc18cdbf108e2414b5fd6d7dbcbe7c7"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a6dc18cdbf108e2414b5fd6d7dbcbe7c7">operator^</a> (const long i) const   throw ()</td></tr>
<tr class="memdesc:a6dc18cdbf108e2414b5fd6d7dbcbe7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power.  <br/></td></tr>
<tr class="memitem:a0a43782634fd4ec2585b8b8ec9128d4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a43782634fd4ec2585b8b8ec9128d4d"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a0a43782634fd4ec2585b8b8ec9128d4d">frobenius</a> () const   throw ()</td></tr>
<tr class="memdesc:a0a43782634fd4ec2585b8b8ec9128d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>p</em>-th power (frobenius morphism). <br/></td></tr>
<tr class="memitem:a6772062dc643f73ea911269e430cb3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a6772062dc643f73ea911269e430cb3c7">frobenius</a> (const long n) const   throw ()</td></tr>
<tr class="memdesc:a6772062dc643f73ea911269e430cb3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>p<sup>n</sup></em>-th power (iterated frobenius morphism).  <a href="#a6772062dc643f73ea911269e430cb3c7"></a><br/></td></tr>
<tr class="memitem:ae73b354cb047113ff835306c49dac752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#ae73b354cb047113ff835306c49dac752">trace</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;F) const   throw (NotASubFieldException)</td></tr>
<tr class="memdesc:ae73b354cb047113ff835306c49dac752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace over the field <em>F</em>.  <a href="#ae73b354cb047113ff835306c49dac752"></a><br/></td></tr>
<tr class="memitem:acea3957b20384779381ec60818cfc208"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acea3957b20384779381ec60818cfc208"></a>
<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#acea3957b20384779381ec60818cfc208">trace</a> () const   throw ()</td></tr>
<tr class="memdesc:acea3957b20384779381ec60818cfc208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace over F<sub>p</sub> <br/></td></tr>
<tr class="memitem:a182575bb5612fdf1eb81bae81436c52a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a182575bb5612fdf1eb81bae81436c52a">pseudotrace</a> (unsigned long n) const   throw ()</td></tr>
<tr class="memdesc:a182575bb5612fdf1eb81bae81436c52a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>n</em>-th pseudotrace  <a href="#a182575bb5612fdf1eb81bae81436c52a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Self-incrementing Unary operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These operators store the result of the operation into the element itself. </p>
</div></td></tr>
<tr class="memitem:aa5dcdc68ffb9d148e7a1f7c2053adbae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5dcdc68ffb9d148e7a1f7c2053adbae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#aa5dcdc68ffb9d148e7a1f7c2053adbae">negate</a> ()  throw ()</td></tr>
<tr class="memdesc:aa5dcdc68ffb9d148e7a1f7c2053adbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the sign of this element. <br/></td></tr>
<tr class="memitem:a1a38b480abaf1919852b475b3d085ce0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a38b480abaf1919852b475b3d085ce0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a1a38b480abaf1919852b475b3d085ce0">self_inv</a> ()  throw (DivisionByZeroException)</td></tr>
<tr class="memdesc:a1a38b480abaf1919852b475b3d085ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert this element. <br/></td></tr>
<tr class="memitem:aadfe2b875505f4a863312a0da7a508cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadfe2b875505f4a863312a0da7a508cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#aadfe2b875505f4a863312a0da7a508cc">operator^=</a> (const ZZ &amp;)  throw ()</td></tr>
<tr class="memdesc:aadfe2b875505f4a863312a0da7a508cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power.  <br/></td></tr>
<tr class="memitem:a3d9ae8548e5d11548c896c1bb934b06d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d9ae8548e5d11548c896c1bb934b06d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a3d9ae8548e5d11548c896c1bb934b06d">operator^=</a> (const long)  throw ()</td></tr>
<tr class="memdesc:a3d9ae8548e5d11548c896c1bb934b06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power.  <br/></td></tr>
<tr class="memitem:aee779cf37270c4644cd6a3dfe5cbcd2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee779cf37270c4644cd6a3dfe5cbcd2d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#aee779cf37270c4644cd6a3dfe5cbcd2d">self_frobenius</a> ()  throw ()</td></tr>
<tr class="memdesc:aee779cf37270c4644cd6a3dfe5cbcd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>p</em>-th power (frobenius morphism).  <br/></td></tr>
<tr class="memitem:a8b035d690384349096493a6e6bc71341"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b035d690384349096493a6e6bc71341"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a8b035d690384349096493a6e6bc71341">self_frobenius</a> (long)  throw ()</td></tr>
<tr class="memdesc:a8b035d690384349096493a6e6bc71341"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>p<sup>n</sup></em>-th power (iterated frobenius morphism).  <br/></td></tr>
<tr class="memitem:a3ccc9245f440ed1352f8c8776ae46c43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ccc9245f440ed1352f8c8776ae46c43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a3ccc9245f440ed1352f8c8776ae46c43">self_trace</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;F)  throw (NotASubFieldException)</td></tr>
<tr class="memdesc:a3ccc9245f440ed1352f8c8776ae46c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace over the field <em>F</em>.  <br/></td></tr>
<tr class="memitem:a2bfab7c4879e368c3473f171220e5f48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bfab7c4879e368c3473f171220e5f48"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a2bfab7c4879e368c3473f171220e5f48">self_trace</a> ()  throw ()</td></tr>
<tr class="memdesc:a2bfab7c4879e368c3473f171220e5f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace over F<sub>p</sub>  <br/></td></tr>
<tr class="memitem:abf275285f89c1021f0150fb9f1008520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#abf275285f89c1021f0150fb9f1008520">self_pseudotrace</a> (unsigned long)  throw ()</td></tr>
<tr class="memdesc:abf275285f89c1021f0150fb9f1008520"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>n</em>-th pseudotrace   <a href="#abf275285f89c1021f0150fb9f1008520"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Minimal polynomials and Evaluation</div></td></tr>
<tr class="memitem:acf43619caeeb67f4570e231f7bc439ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf43619caeeb67f4570e231f7bc439ec"></a>
<a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#acf43619caeeb67f4570e231f7bc439ec">minimalPolynomial</a> () const   throw ()</td></tr>
<tr class="memdesc:acf43619caeeb67f4570e231f7bc439ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimal polynomial over F<sub>p</sub>. <br/></td></tr>
<tr class="memitem:a0310c2a324049bbe7e8c581e433ba3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a0310c2a324049bbe7e8c581e433ba3ec">minimalPolynomial</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;F) const   throw (NotASubFieldException, NotSupportedException)</td></tr>
<tr class="memdesc:a0310c2a324049bbe7e8c581e433ba3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimal polynomial over the field <em>F</em>.  <a href="#a0310c2a324049bbe7e8c581e433ba3ec"></a><br/></td></tr>
<tr class="memitem:ad51450edaf667d6143caff88c127a4a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8">minimalPolynomials</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;F, vector&lt; <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &gt; &amp;res) const   throw (NotASubFieldException, NotSupportedException)</td></tr>
<tr class="memdesc:ad51450edaf667d6143caff88c127a4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the minimal polynomials up to the field <em>F</em>.  <a href="#ad51450edaf667d6143caff88c127a4a8"></a><br/></td></tr>
<tr class="memitem:a5995bc4c6a240bb5598cc6202857057e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a5995bc4c6a240bb5598cc6202857057e">affineMinimalPolynomial</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;F, const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;a, vector&lt; <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &gt; &amp;minpols) const   throw (NotASubFieldException, NoSuchPolynomialException,		NotSupportedException, BadParametersException)</td></tr>
<tr class="memdesc:a5995bc4c6a240bb5598cc6202857057e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <em>a</em>-affine minimal polynomial over the field <em>F</em>.   <a href="#a5995bc4c6a240bb5598cc6202857057e"></a><br/></td></tr>
<tr class="memitem:ac6e67226adc873b1fdadc70ccb9d0ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#ac6e67226adc873b1fdadc70ccb9d0ff9">affineMinimalPolynomial</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;F, const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;a) const   throw (NotASubFieldException, NoSuchPolynomialException,		NotSupportedException)</td></tr>
<tr class="memdesc:ac6e67226adc873b1fdadc70ccb9d0ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <em>a</em>-affine minimal polynomial over the field <em>F</em>.  <a href="#ac6e67226adc873b1fdadc70ccb9d0ff9"></a><br/></td></tr>
<tr class="memitem:aaaf6a31335f37a58ac6f881ab853d598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#aaaf6a31335f37a58ac6f881ab853d598">evaluate</a> (const <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &amp;P, vector&lt; <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &gt; &amp;minpols) const   throw (IllegalCoercionException, BadParametersException)</td></tr>
<tr class="memdesc:aaaf6a31335f37a58ac6f881ab853d598"><td class="mdescLeft">&#160;</td><td class="mdescRight">The evaulation of <em>P</em> at this element.   <a href="#aaaf6a31335f37a58ac6f881ab853d598"></a><br/></td></tr>
<tr class="memitem:ac28c78e7ad601c5a7a3f82bdb9a14ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#ac28c78e7ad601c5a7a3f82bdb9a14ed2">evaluate</a> (const <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &amp;P) const   throw (IllegalCoercionException)</td></tr>
<tr class="memdesc:ac28c78e7ad601c5a7a3f82bdb9a14ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The evaulation of <em>P</em> at this element.  <a href="#ac28c78e7ad601c5a7a3f82bdb9a14ed2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Coercion of elements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Every element has an unique <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>, but it may belong to some subfield of its <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> or you may want to change its <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> to an overfield of its actual one. Coercion does exactly this. When the coericion is impossible because either there is no known embedding between the two fields or because the element does not belong to the new field, an <a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a> is thrown. </p>
</div></td></tr>
<tr class="memitem:ab9e870744e97e4a41fdbff5d2aacd194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#ab9e870744e97e4a41fdbff5d2aacd194">toScalar</a> () const   throw (IllegalCoercionException)</td></tr>
<tr class="memdesc:ab9e870744e97e4a41fdbff5d2aacd194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce to a scalar.  <a href="#ab9e870744e97e4a41fdbff5d2aacd194"></a><br/></td></tr>
<tr class="memitem:a60b6cc645fa5f500d168183bcefb5c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a60b6cc645fa5f500d168183bcefb5c27">operator&gt;&gt;</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;F) const   throw (IllegalCoercionException)</td></tr>
<tr class="memdesc:a60b6cc645fa5f500d168183bcefb5c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce to the field <em>F</em>.  <a href="#a60b6cc645fa5f500d168183bcefb5c27"></a><br/></td></tr>
<tr class="memitem:ad2ef90a555f88dc2dbe3b0fc3bd63f91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#ad2ef90a555f88dc2dbe3b0fc3bd63f91">operator&gt;&gt;=</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;)  throw (IllegalCoercionException)</td></tr>
<tr class="memdesc:ad2ef90a555f88dc2dbe3b0fc3bd63f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce to the field <em>F</em> and store the result in this element.  <a href="#ad2ef90a555f88dc2dbe3b0fc3bd63f91"></a><br/></td></tr>
<tr class="memitem:a1aaa103e1ac4fe76a8e8f4e011dc6f52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aaa103e1ac4fe76a8e8f4e011dc6f52"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a1aaa103e1ac4fe76a8e8f4e011dc6f52">isCoercible</a> (const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;) const   throw ()</td></tr>
<tr class="memdesc:a1aaa103e1ac4fe76a8e8f4e011dc6f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this element is coercible to <em>F</em>. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Predicates</div></td></tr>
<tr class="memitem:a2b8600d419a2c466128111af014e1141"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a2b8600d419a2c466128111af014e1141">operator==</a> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;) const   throw (NotInSameFieldException)</td></tr>
<tr class="memdesc:a2b8600d419a2c466128111af014e1141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality.  <a href="#a2b8600d419a2c466128111af014e1141"></a><br/></td></tr>
<tr class="memitem:ad99e17dd1068a326c238e5861e42f831"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad99e17dd1068a326c238e5861e42f831"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#ad99e17dd1068a326c238e5861e42f831">operator==</a> (const BigInt &amp;) const   throw ()</td></tr>
<tr class="memdesc:ad99e17dd1068a326c238e5861e42f831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality. <br/></td></tr>
<tr class="memitem:ab3ec705e9f61fa5aecd0b8439297c40a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#ab3ec705e9f61fa5aecd0b8439297c40a">operator!=</a> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e) const   throw (NotInSameFieldException)</td></tr>
<tr class="memdesc:ab3ec705e9f61fa5aecd0b8439297c40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality.  <a href="#ab3ec705e9f61fa5aecd0b8439297c40a"></a><br/></td></tr>
<tr class="memitem:a3d2d1017e552d719a9b38dcc1dee3256"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d2d1017e552d719a9b38dcc1dee3256"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a3d2d1017e552d719a9b38dcc1dee3256">operator!=</a> (const BigInt &amp;i) const   throw ()</td></tr>
<tr class="memdesc:a3d2d1017e552d719a9b38dcc1dee3256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality. <br/></td></tr>
<tr class="memitem:a25007deceac0c37df17dcc2236936b82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25007deceac0c37df17dcc2236936b82"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a25007deceac0c37df17dcc2236936b82">isZero</a> () const   throw ()</td></tr>
<tr class="memdesc:a25007deceac0c37df17dcc2236936b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to zero. <br/></td></tr>
<tr class="memitem:a36649a2cd7c785af9513fc345095b466"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36649a2cd7c785af9513fc345095b466"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a36649a2cd7c785af9513fc345095b466">isOne</a> () const   throw ()</td></tr>
<tr class="memdesc:a36649a2cd7c785af9513fc345095b466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to one. <br/></td></tr>
<tr class="memitem:a44b47402b061d831e0ee6f403f2316d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a44b47402b061d831e0ee6f403f2316d8">isScalar</a> () const   throw ()</td></tr>
<tr class="memdesc:a44b47402b061d831e0ee6f403f2316d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this element belongs to F<sub>p</sub>.  <a href="#a44b47402b061d831e0ee6f403f2316d8"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to the Infrastructure</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods let you access the internal <code><a class="el" href="References.html#NTL">NTL</a></code> representation of elements.</p>
<dl class="section warning"><dt>Warning</dt><dd>These methods are for advanced use only. Use them if you want to use an algorithm by you or in NTL that is not available for <a class="el" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">FieldElement</a>. </dd></dl>
</div></td></tr>
<tr class="memitem:a3fa3a69553ab9b8575326a438e002001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a3fa3a69553ab9b8575326a438e002001">toInfrastructure</a> (GFp &amp;e) const   throw (IllegalCoercionException)</td></tr>
<tr class="memdesc:a3fa3a69553ab9b8575326a438e002001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the representation of elements whose <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is F<sub>p</sub>.  <a href="#a3fa3a69553ab9b8575326a438e002001"></a><br/></td></tr>
<tr class="memitem:a46df554f7c00f5d299a8b200a0db6a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a46df554f7c00f5d299a8b200a0db6a31">toInfrastructure</a> (GFpE &amp;e) const   throw (IllegalCoercionException)</td></tr>
<tr class="memdesc:a46df554f7c00f5d299a8b200a0db6a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the representation of elements whose <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is an extension field.  <a href="#a46df554f7c00f5d299a8b200a0db6a31"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Printing</div></td></tr>
<tr class="memitem:a7666d255b74f91b08f029666a3d8f29a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7666d255b74f91b08f029666a3d8f29a"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a7666d255b74f91b08f029666a3d8f29a">print</a> (ostream &amp;o) const </td></tr>
<tr class="memdesc:a7666d255b74f91b08f029666a3d8f29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print this element to <em>o</em>. <br/></td></tr>
<tr class="memitem:a2e0d0a675782a8f3bccd77e132a25371"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e0d0a675782a8f3bccd77e132a25371"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a2e0d0a675782a8f3bccd77e132a25371">print</a> (ostream &amp;o, const string &amp;var) const </td></tr>
<tr class="memdesc:a2e0d0a675782a8f3bccd77e132a25371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print this element to <em>o</em> as a polynomial over F<sub>p</sub> in the variable <em>var</em>. <br/></td></tr>
<tr class="memitem:a24c9b7a24bafb4f1ad9798aa31333afb"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a24c9b7a24bafb4f1ad9798aa31333afb">print</a> (ostream &amp;o, const vector&lt; string &gt; &amp;vars) const </td></tr>
<tr class="memdesc:a24c9b7a24bafb4f1ad9798aa31333afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print this element to <em>o</em> as a multivariate polynomial over F<sub>p</sub>.  <a href="#a24c9b7a24bafb4f1ad9798aa31333afb"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:acc1e83d603a387d3a875f52ca2842e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#acc1e83d603a387d3a875f52ca2842e0b">pushDown</a> (const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e, vector&lt; <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &gt; &amp;v)  throw (NoSubFieldException)</td></tr>
<tr class="memdesc:acc1e83d603a387d3a875f52ca2842e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>e</em> from the internal (univariate) representation to the bivariate representation over the immediate subfield in the primitive tower (the stem).  <a href="#acc1e83d603a387d3a875f52ca2842e0b"></a><br/></td></tr>
<tr class="memitem:a8578eb66961b7bbc23c9887eab174cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a8578eb66961b7bbc23c9887eab174cea">liftUp</a> (const vector&lt; <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &gt; &amp;v, <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e)  throw (NotInSameFieldException, NoOverFieldException)</td></tr>
<tr class="memdesc:a8578eb66961b7bbc23c9887eab174cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <em>v</em> from the bivariate representation over the immediate subfield in the primitive tower (the stem) to the internal (univariate) representation.  <a href="#a8578eb66961b7bbc23c9887eab174cea"></a><br/></td></tr>
<tr class="memitem:a93d7dc9d99132298d29fe5a1ff11f990"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93d7dc9d99132298d29fe5a1ff11f990"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a93d7dc9d99132298d29fe5a1ff11f990"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFAAST_1_1FieldElement.html#a93d7dc9d99132298d29fe5a1ff11f990">operator&lt;&lt;</a> (ostream &amp;o, const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;e)</td></tr>
<tr class="memdesc:a93d7dc9d99132298d29fe5a1ff11f990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print <em>e</em> to <em>o</em>. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Local types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp44864d85451a0b0eaf88c5ff10d15178"></a>Local types defined in this class. They are aliases to simplify the access to the <a class="el" href="group__Infrastructures.html">Infrastructure</a> <em>T</em> and its subtypes.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Infrastructures.html">Infrastructures</a>. </dd></dl>
</td></tr>
<tr class="memitem:adacf7d1eee23e4cb2fbe3c2aea254aab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adacf7d1eee23e4cb2fbe3c2aea254aab"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>Infrastructure</b></td></tr>
<tr class="memitem:a4f6463b0a6bd0bd9687febc954bdb524"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f6463b0a6bd0bd9687febc954bdb524"></a>
typedef T::GFp&#160;</td><td class="memItemRight" valign="bottom"><b>GFp</b></td></tr>
<tr class="memitem:a1d9860912b38e3fc6611eb25759ed298"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d9860912b38e3fc6611eb25759ed298"></a>
typedef T::MatGFp&#160;</td><td class="memItemRight" valign="bottom"><b>MatGFp</b></td></tr>
<tr class="memitem:a4fb7e60691e9b4eb013b98e4813749f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb7e60691e9b4eb013b98e4813749f4"></a>
typedef T::GFpX&#160;</td><td class="memItemRight" valign="bottom"><b>GFpX</b></td></tr>
<tr class="memitem:a9988a5142317641dfb53b5ee79b1e496"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9988a5142317641dfb53b5ee79b1e496"></a>
typedef T::GFpE&#160;</td><td class="memItemRight" valign="bottom"><b>GFpE</b></td></tr>
<tr class="memitem:a051d1a93b6d19a44ef1174489a672938"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a051d1a93b6d19a44ef1174489a672938"></a>
typedef T::GFpEX&#160;</td><td class="memItemRight" valign="bottom"><b>GFpEX</b></td></tr>
<tr class="memitem:a8fa4abdd862ea79cfe912c0e19f9152f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fa4abdd862ea79cfe912c0e19f9152f"></a>
typedef T::BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>BigInt</b></td></tr>
<tr class="memitem:ab2249c809267ad101f766ce991cc5c31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2249c809267ad101f766ce991cc5c31"></a>
typedef T::Context&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class FAAST::FieldElement&lt; T &gt;</h3>

<p>An element of a finite field. </p>
<p>Objects of this class represent elements of a finite field, as represented by the class <a class="el" href="classFAAST_1_1Field.html" title="A finite field.">Field</a>. With the exception of the zero element created by the <a class="el" href="classFAAST_1_1FieldElement.html#a8503d1b29ed7a86a9237ad5d5db663a2">default constructor</a>, any element has an unique <em>parent</em> <em>field</em> and binary operations can combine two elements only in one of the following two cases:</p>
<ul>
<li>the two elements have the same parent field,</li>
<li>the parent element of one element is the <a class="el" href="classFAAST_1_1Field.html#a04ca553af2b57d63ed43cba96a60d32d">prime field</a> of the other's.</li>
</ul>
<p>Elements created through the <a class="el" href="classFAAST_1_1FieldElement.html#a8503d1b29ed7a86a9237ad5d5db663a2">default constructor</a>, as for example </p>
<div class="fragment"><div class="line">FieldElement&lt;T&gt; elt;</div>
</div><!-- fragment --><p> have a special status as they don't belong to any specific field: their default value is 0 and they can be combined with any other element. The result of a binary operation involving such a special element is one of the following:</p>
<ul>
<li>A <a class="el" href="classFAAST_1_1DivisionByZeroException.html" title="Division by zero.">DivisionByZeroException</a> if the operation is division and the divisor is the special 0 element.</li>
<li>An element of field <b>K</b>, if <b>K</b> is the parent field of the other element.</li>
<li>The special 0 element if the other element is the special 0 element.</li>
<li>An <a class="el" href="classFAAST_1_1UndefinedFieldException.html" title="The element has no parent field specified.">UndefinedFieldException</a> if the other element is not the special 0 element and yet does not belong to any field, as in this example <div class="fragment"><div class="line">FieldElement&lt;T&gt; elt;</div>
<div class="line"><span class="keywordflow">return</span> elt + 1;</div>
</div><!-- fragment --> See <a class="el" href="classFAAST_1_1UndefinedFieldException.html" title="The element has no parent field specified.">UndefinedFieldException</a> for more details.</li>
</ul>
<p>Elements are internally represented as univariate polynomials with coefficients in F<sub>p</sub> modulo an irreducible polynomial as described in [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 3]. The way the arithmetics of the field are actually implemented is given by the template parameter <em>T</em> that must be one of the <a class="el" href="group__Infrastructures.html">Infrastructures</a>. Note that changing the Infrastructure may sensibly change the speed of your code.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An <a class="el" href="group__Infrastructures.html">Infrastructure</a>. It specfies which <code><a class="el" href="References.html#NTL">NTL</a></code> types will carry out the arithmetic operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1Field.html" title="A finite field.">Field</a>, <a class="el" href="classFAAST_1_1UndefinedFieldException.html" title="The element has no parent field specified.">UndefinedFieldException</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_8c_09_09-example.html#_a1">test.c++</a>, <a class="el" href="testIso_8c_09_09-example.html#_a1">testIso.c++</a>, <a class="el" href="testLE_8c_09_09-example.html#_a1">testLE.c++</a>, <a class="el" href="testStem_8c_09_09-example.html#_a1">testStem.c++</a>, <a class="el" href="testTraceFrob_8c_09_09-example.html#_a1">testTraceFrob.c++</a>, and <a class="el" href="using_infrastructure_8c_09_09-example.html#_a4">using_infrastructure.c++</a>.</dd>
</dl></div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8503d1b29ed7a86a9237ad5d5db663a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::<a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the special 0 element. </p>
<p>The special 0 element does not belong to any field, yet it can be added, multiplied, etc. to any other <a class="el" href="classFAAST_1_1FieldElement.html" title="An element of a finite field.">FieldElement</a>. See the <a class="el" href="classFAAST_1_1FieldElement.html">introduction </a> for more details. If you want to construct the 0 element of a specific field, use <a class="el" href="classFAAST_1_1Field.html#a7c578d1c7f56b0b8a3d3c2f1780165ba" title="The zero element of this field.">Field::zero()</a> instead.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1UndefinedFieldException.html" title="The element has no parent field specified.">UndefinedFieldException</a>, <a class="el" href="classFAAST_1_1Field.html#a7c578d1c7f56b0b8a3d3c2f1780165ba" title="The zero element of this field.">Field::zero()</a>. </dd></dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a5995bc4c6a240bb5598cc6202857057e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::affineMinimalPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>minpols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const  throw (<a class="el" href="classFAAST_1_1NotASubFieldException.html">NotASubFieldException</a>, <a class="el" href="classFAAST_1_1NoSuchPolynomialException.html">NoSuchPolynomialException</a>,		<a class="el" href="classFAAST_1_1NotSupportedException.html">NotSupportedException</a>, <a class="el" href="classFAAST_1_1BadParametersException.html">BadParametersException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <em>a</em>-affine minimal polynomial over the field <em>F</em>.  </p>
<p>This is an optimized version of <a class="el" href="classFAAST_1_1FieldElement.html#ac6e67226adc873b1fdadc70ccb9d0ff9" title="The a-affine minimal polynomial over the field F.">affineMinimalPolynomial(const Field&lt;T&gt;&amp;, const FieldElement&lt;T&gt;&amp;) const</a> that lets you pass an additional parameter <em>minpols</em> containing some precomputed quantities.</p>
<p>The optional parameter <em>minpols</em> must contain either the result of <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a>, or must be an empty vector, in which case it is filled with the result of <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a>. In any other case either a <a class="el" href="classFAAST_1_1BadParametersException.html" title="The function does not accept such parameters.">BadParametersException</a> is thrown or the behaviour is undefined.</p>
<p>This method should be preferred when you care about efficiency and you do many calls to <a class="el" href="classFAAST_1_1FieldElement.html#a5995bc4c6a240bb5598cc6202857057e" title="const">affineMinimalPolynomial()</a> and <a class="el" href="classFAAST_1_1FieldElement.html#aaaf6a31335f37a58ac6f881ab853d598" title="const">evaluate()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>A subfield of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>An element contained in the field F[<em>x</em>], where <em>x</em> is this element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">minpols</td><td>If this vector is empty, then <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a> is called, otherwise it is assumed to contain the data computed by the former method call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>a</em>-affine minimal polynomial over the field <em>F</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotASubFieldException.html" title="The field is not a subfield of the given field.">NotASubFieldException</a></td><td>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is not an extension field of <em>F</em>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotSupportedException.html" title="The operation is not supported (yet?)">NotSupportedException</a></td><td>If <em>F</em> is a prime field not being the base field of an Artin-Schreier tower. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NoSuchPolynomialException.html" title="There is no polynomial with the given property.">NoSuchPolynomialException</a></td><td>If no such polynomial exists. Equivalently, if <em>a</em> is not an element of F[<em>x</em>] where <em>x</em> is this element. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1BadParametersException.html" title="The function does not accept such parameters.">BadParametersException</a></td><td>If <em>minpols</em> is not empty or does not contain the result of <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1FieldElement.html#ac6e67226adc873b1fdadc70ccb9d0ff9" title="The a-affine minimal polynomial over the field F.">affineMinimalPolynomial(const Field&lt;T&gt;&amp;, const FieldElement&lt;T&gt;&amp;) const</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_8c_09_09-example.html#a8">test.c++</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac6e67226adc873b1fdadc70ccb9d0ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt;T&gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::affineMinimalPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const  throw (<a class="el" href="classFAAST_1_1NotASubFieldException.html">NotASubFieldException</a>, <a class="el" href="classFAAST_1_1NoSuchPolynomialException.html">NoSuchPolynomialException</a>,		<a class="el" href="classFAAST_1_1NotSupportedException.html">NotSupportedException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <em>a</em>-affine minimal polynomial over the field <em>F</em>. </p>
<p>That is the minimum degree polynomial <em>P</em> of <em>F</em>[X] such that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(x) = \mathtt{a}\mathrm{,} \]" src="form_5.png"/>
</p>
<p> where <em>x</em> is this element. Observe that this is the same as computing the interpolation polynomial such that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P\bigl(\phi_F^n(x)\bigr) = \phi_F^n(\mathtt{a}) \quad \forall n\mathrm{,} \]" src="form_6.png"/>
</p>
<p> where <img class="formulaInl" alt="$ \phi_F $" src="form_7.png"/> is the frobenius morphism fixing <em>F</em>. This implements a yet unpublished algorithm, it only works when <em>F</em> is a field of an Artin-Schreier tower as constructed in [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 3].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>A subfield of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>An element contained in the field F[<em>x</em>], where <em>x</em> is this element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>a</em>-affine minimal polynomial over the field <em>F</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotASubFieldException.html" title="The field is not a subfield of the given field.">NotASubFieldException</a></td><td>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is not an extension field of <em>F</em>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotSupportedException.html" title="The operation is not supported (yet?)">NotSupportedException</a></td><td>If <em>F</em> is a prime field not being the base field of an Artin-Schreier tower. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NoSuchPolynomialException.html" title="There is no polynomial with the given property.">NoSuchPolynomialException</a></td><td>If no such polynomial exists. Equivalently, if <em>a</em> is not an element of the field F[<em>x</em>], where <em>x</em> is this element. <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaf6a31335f37a58ac6f881ab853d598"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>minpols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const  throw (<a class="el" href="classFAAST_1_1IllegalCoercionException.html">IllegalCoercionException</a>, <a class="el" href="classFAAST_1_1BadParametersException.html">BadParametersException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The evaulation of <em>P</em> at this element.  </p>
<p>This is an optimized version of <a class="el" href="classFAAST_1_1FieldElement.html#ac28c78e7ad601c5a7a3f82bdb9a14ed2" title="The evaulation of P at this element.">evaluate(const FieldPolynomial&lt;T&gt;&amp;) const</a> that lets you pass an additional parameter <em>minpols</em> containing some precomputed quantities.</p>
<p>The optional parameter <em>minpols</em> must contain either the result of <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a>, or must be an empty vector, in which case it is filled with the result of <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a>. In any other case either a <a class="el" href="classFAAST_1_1BadParametersException.html" title="The function does not accept such parameters.">BadParametersException</a> is thrown or the behaviour is undefined.</p>
<p>This method should be preferred when you care about efficiency and you do many calls to <a class="el" href="classFAAST_1_1FieldElement.html#a5995bc4c6a240bb5598cc6202857057e" title="const">affineMinimalPolynomial()</a> and <a class="el" href="classFAAST_1_1FieldElement.html#aaaf6a31335f37a58ac6f881ab853d598" title="const">evaluate()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>A polynomial with coefficients in a subfield or overfield of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">minpols</td><td>If this vector is empty, then <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a> is called, otherwise it is assumed to contain the data computed by the former method call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluation of <em>P</em> at this element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a></td><td>If this element cannot be coerced to the coefficient field of <em>P</em> nor can <em>P</em> be coerced to the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1BadParametersException.html" title="The function does not accept such parameters.">BadParametersException</a></td><td>If <em>minpols</em> is not empty or does not contain the result of <a class="el" href="classFAAST_1_1FieldElement.html#ad51450edaf667d6143caff88c127a4a8"><code>minimalPolynomials(F,minpols)</code> </a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section invariant"><dt>Invariant</dt><dd>This is the same as <a class="el" href="classFAAST_1_1FieldPolynomial.html#a1bb4541b76fe949dd1fa6b89c34aea4b"><code>P.evaluate(*this, minpols)</code> </a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1FieldElement.html#ac28c78e7ad601c5a7a3f82bdb9a14ed2" title="The evaulation of P at this element.">evaluate(const FieldPolynomial&lt;T&gt;&amp;) const</a>, <a class="el" href="classFAAST_1_1FieldPolynomial.html#a1bb4541b76fe949dd1fa6b89c34aea4b" title="The evaulation of this polynomial at e.">FieldPolynomial::evaluate()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_8c_09_09-example.html#a10">test.c++</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac28c78e7ad601c5a7a3f82bdb9a14ed2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt;T&gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1IllegalCoercionException.html">IllegalCoercionException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The evaulation of <em>P</em> at this element. </p>
<p>This implements a yet unpublished algorithm for Artin-Schreier towers constructed as in [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 3]. It uses Horner evaluation scheme for all the other cases.</p>
<p>The optional parameter minpols must contain either the result of this.minimalPolynomials(P.parent,v), or must be an empty vector, in which case it is filled with the result of minimalPolynomials(P.parent,v).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>A polynomial with coefficients in a subfield or overfield of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluation of <em>P</em> at this element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a></td><td>If this element cannot be coerced to the coefficient field of <em>P</em> nor can <em>P</em> be coerced to the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section invariant"><dt>Invariant</dt><dd>This is the same as <a class="el" href="classFAAST_1_1FieldPolynomial.html#a1bb4541b76fe949dd1fa6b89c34aea4b"><code>P.evaluate(*this)</code> </a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1FieldPolynomial.html#a1bb4541b76fe949dd1fa6b89c34aea4b" title="The evaulation of this polynomial at e.">FieldPolynomial::evaluate()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6772062dc643f73ea911269e430cb3c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt;T&gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::frobenius </td>
          <td>(</td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>p<sup>n</sup></em>-th power (iterated frobenius morphism). </p>
<p>This method is a generalization of the algorithm <code>IterFrobenius</code> of [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 5]. </p>

</div>
</div>
<a class="anchor" id="a44b47402b061d831e0ee6f403f2316d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::isScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this element belongs to F<sub>p</sub>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1FieldElement.html#ab9e870744e97e4a41fdbff5d2aacd194" title="Coerce to a scalar.">toScalar()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0310c2a324049bbe7e8c581e433ba3ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt;T&gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::minimalPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1NotASubFieldException.html">NotASubFieldException</a>, <a class="el" href="classFAAST_1_1NotSupportedException.html">NotSupportedException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimal polynomial over the field <em>F</em>. </p>
<p>This method implements a yet unpublished algorithm to compute minimal polynomials in Artin-Schreier towers. It only works when <em>F</em> is a field of an Artin-Schreier tower as constructed in [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 3].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>A subfield of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of this element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial over <em>F</em> being the minimal polynomial of this element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotASubFieldException.html" title="The field is not a subfield of the given field.">NotASubFieldException</a></td><td>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is not an extension field of <em>F</em>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotSupportedException.html" title="The operation is not supported (yet?)">NotSupportedException</a></td><td>If <em>F</em> is a prime field not being the base field of an Artin-Schreier tower. Use <a class="el" href="classFAAST_1_1FieldElement.html#acf43619caeeb67f4570e231f7bc439ec" title="The minimal polynomial over Fp.">minimalPolynomial()</a> instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad51450edaf667d6143caff88c127a4a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::minimalPolynomials </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classFAAST_1_1FieldPolynomial.html">FieldPolynomial</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const  throw (<a class="el" href="classFAAST_1_1NotASubFieldException.html">NotASubFieldException</a>, <a class="el" href="classFAAST_1_1NotSupportedException.html">NotSupportedException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All the minimal polynomials up to the field <em>F</em>. </p>
<p>The result is the same as doing </p>
<div class="fragment"><div class="line">res[0] = <a class="code" href="classFAAST_1_1FieldElement.html#acf43619caeeb67f4570e231f7bc439ec" title="The minimal polynomial over Fp.">minimalPolynomial</a>(F);</div>
<div class="line">res[1] = <a class="code" href="classFAAST_1_1FieldElement.html#acf43619caeeb67f4570e231f7bc439ec" title="The minimal polynomial over Fp.">minimalPolynomial</a>(F.overField());</div>
<div class="line">res[2] = <a class="code" href="classFAAST_1_1FieldElement.html#acf43619caeeb67f4570e231f7bc439ec" title="The minimal polynomial over Fp.">minimalPolynomial</a>(F.overField().overField());</div>
<div class="line">...</div>
</div><!-- fragment --><p> up to <code>minimalPolynomial</code>(<a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438" title="The parent field.">parent()</a>). The computation is more efficient, though.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>A subfield of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> field. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>The vector is filled with the minimal polynomials of this element over the intermediate extension fields of F. All previous data are discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotASubFieldException.html" title="The field is not a subfield of the given field.">NotASubFieldException</a></td><td>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is not an extension field of <em>F</em>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotSupportedException.html" title="The operation is not supported (yet?)">NotSupportedException</a></td><td>If <em>F</em> is a prime field not being the base field of an Artin-Schreier tower. Use <a class="el" href="classFAAST_1_1FieldElement.html#acf43619caeeb67f4570e231f7bc439ec" title="The minimal polynomial over Fp.">minimalPolynomial()</a> instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1FieldElement.html#a0310c2a324049bbe7e8c581e433ba3ec" title="The minimal polynomial over the field F.">minimalPolynomial(const Field&lt;T&gt;&amp;) const</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_8c_09_09-example.html#a6">test.c++</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab3ec705e9f61fa5aecd0b8439297c40a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1NotInSameFieldException.html">NotInSameFieldException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality. </p>
<p>This method does not try to coerce the elements to the same field to test equality. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotInSameFieldException.html" title="The two elements do not belong to the same field.">NotInSameFieldException</a></td><td>If the two elements do not have de same <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbaf9194f2688bb675c0916211aacff4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td>  throw (<a class="el" href="classFAAST_1_1UndefinedFieldException.html">UndefinedFieldException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a scalar value to this element. </p>
<p>The <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of the element does not change through the assignment.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the result. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1UndefinedFieldException.html" title="The element has no parent field specified.">UndefinedFieldException</a></td><td>If this is the <a class="el" href="classFAAST_1_1FieldElement.html#a8503d1b29ed7a86a9237ad5d5db663a2">special 0 element </a> and <em>i</em> is different from 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b8600d419a2c466128111af014e1141"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1NotInSameFieldException.html">NotInSameFieldException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality. </p>
<p>This method does not try to coerce the elements to the same field to test equality. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotInSameFieldException.html" title="The two elements do not belong to the same field.">NotInSameFieldException</a></td><td>If the two elements do not have de same <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60b6cc645fa5f500d168183bcefb5c27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt;T&gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1IllegalCoercionException.html">IllegalCoercionException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Coerce to the field <em>F</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>A finite subfield or overfield of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>, containing this element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a></td><td>If no embedding is known between the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> and <em>F</em> or if this element does not belong to <em>F</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2ef90a555f88dc2dbe3b0fc3bd63f91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td>  throw (<a class="el" href="classFAAST_1_1IllegalCoercionException.html">IllegalCoercionException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coerce to the field <em>F</em> and store the result in this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>A finite subfield or overfield of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>, containing this element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a></td><td>If no embedding is known between the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> and <em>F</em> or if this element does not belong to <em>F</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78120b7dff3255ead926f22a466fc438"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt;T&gt;&amp; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1UndefinedFieldException.html">UndefinedFieldException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <em>parent</em> <em>field</em>. </p>
<p>With the exception of the zero element created by the <a class="el" href="classFAAST_1_1FieldElement.html#a8503d1b29ed7a86a9237ad5d5db663a2">default constructor</a>, any element has an unique <em>parent</em> <em>field</em> and binary operations can combine two elements only in one of the following two cases:</p>
<ul>
<li>the two elements have the same parent field,</li>
<li>the parent element of one element is the <a class="el" href="classFAAST_1_1Field.html#a04ca553af2b57d63ed43cba96a60d32d">prime field</a> of the other's.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1UndefinedFieldException.html" title="The element has no parent field specified.">UndefinedFieldException</a></td><td>If this element does not belong to any field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1FieldElement.html#a8503d1b29ed7a86a9237ad5d5db663a2" title="Construct the special 0 element.">FieldElement()</a>, <a class="el" href="classFAAST_1_1UndefinedFieldException.html" title="The element has no parent field specified.">UndefinedFieldException</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a24c9b7a24bafb4f1ad9798aa31333afb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print this element to <em>o</em> as a multivariate polynomial over F<sub>p</sub>. </p>
<p>The number of variables in <em>vars</em> must be at least one plus the <a class="el" href="classFAAST_1_1Field.html#af9967583c384a381c0804dd3f6b465da">Artin-Schreier height</a> of the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. The recursive descent along the tower is done via <a class="el" href="classFAAST_1_1Field.html#ac35d44bfcaff36077b66015bfbea15aa" title="Convert the univariate representation of e to the multivariate representation over this field...">Field::toBivariate()</a>, the list of the fields involved in the descent is internally stored and reproduces backwards the list of calls to <a class="el" href="classFAAST_1_1Field.html#a9a03bb939246ee9548c251a6541ce3eb" title="Build a primitive extension of degree p as in [DFS &#39;09, Section 3].">Field::ArtinSchreierExtension</a> that have created the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>An output stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>A vector of variable names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the modified stream. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1BadParametersException.html" title="The function does not accept such parameters.">BadParametersException</a></td><td>If there is not enough variables in <em>vars</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>This method sucks! </dd></dl>

</div>
</div>
<a class="anchor" id="a182575bb5612fdf1eb81bae81436c52a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt;T&gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::pseudotrace </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>n</em>-th pseudotrace </p>
<p>Let <em>x</em> be this element, the <em>n</em>-th pseudotrace, noted T<sub>n</sub>(x) is </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathrm{T}_n(x) = \sum_{\ell=0}^{n-1} x^{p^\ell} \mathrm{.} \]" src="form_4.png"/>
</p>
<p> This method is a generalization of the algorithm <code>Pseudotrace</code> of [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 5]. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="testTraceFrob_8c_09_09-example.html#a7">testTraceFrob.c++</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abf275285f89c1021f0150fb9f1008520"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::self_pseudotrace </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>n</em>-th pseudotrace  </p>
<p>Let <em>x</em> be this element, the <em>n</em>-th pseudotrace, noted T<sub>n</sub>(x) is </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathrm{T}_n(x) = \sum_{\ell=0}^{n-1} x^{p^\ell} \mathrm{.} \]" src="form_4.png"/>
</p>
<p> This method is a generalization of the algorithm <code>Pseudotrace</code> of [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 5].  </p>

</div>
</div>
<a class="anchor" id="a3fa3a69553ab9b8575326a438e002001"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::toInfrastructure </td>
          <td>(</td>
          <td class="paramtype">GFp &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1IllegalCoercionException.html">IllegalCoercionException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the representation of elements whose <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is F<sub>p</sub>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">e</td><td>An <code><a class="el" href="References.html#NTL">NTL</a></code> scalar element to hold the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a></td><td>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is not a prime field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method automatically switches the context to the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> context. See <a class="el" href="classFAAST_1_1Field.html#ae07db83f40be93cf6d8eece913fbddef" title="Set the current context to this field&#39;s context.">Field::switchContext()</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="using_infrastructure_8c_09_09-example.html">using_infrastructure.c++ </a>, <a class="el" href="classFAAST_1_1Field.html#af37d30843638794d31d89f42cb248a0a" title="Build an element of this field from an NTL type.">Field::fromInfrastructure()</a>, <a class="el" href="classFAAST_1_1Field.html#ae07db83f40be93cf6d8eece913fbddef" title="Set the current context to this field&#39;s context.">Field::switchContext()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a46df554f7c00f5d299a8b200a0db6a31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::toInfrastructure </td>
          <td>(</td>
          <td class="paramtype">GFpE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1IllegalCoercionException.html">IllegalCoercionException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the representation of elements whose <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is an extension field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">e</td><td>An <code><a class="el" href="References.html#NTL">NTL</a></code> element to hold the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a></td><td>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> is a prime field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method automatically switches the context to the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> context. See <a class="el" href="classFAAST_1_1Field.html#ae07db83f40be93cf6d8eece913fbddef" title="Set the current context to this field&#39;s context.">Field::switchContext()</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="using_infrastructure_8c_09_09-example.html">using_infrastructure.c++ </a>, <a class="el" href="classFAAST_1_1Field.html#af37d30843638794d31d89f42cb248a0a" title="Build an element of this field from an NTL type.">Field::fromInfrastructure()</a>, <a class="el" href="classFAAST_1_1Field.html#ae07db83f40be93cf6d8eece913fbddef" title="Set the current context to this field&#39;s context.">Field::switchContext()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9e870744e97e4a41fdbff5d2aacd194"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::toScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1IllegalCoercionException.html">IllegalCoercionException</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coerce to a scalar. </p>
<p>Coerce to an element of F<sub>p</sub>.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly created element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1IllegalCoercionException.html" title="The element cannot be coerced to the given field.">IllegalCoercionException</a></td><td>If the element is not a scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section invariant"><dt>Invariant</dt><dd>This is the same as doing <div class="fragment"><div class="line">*<span class="keyword">this</span> &gt;&gt; <a class="code" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438" title="The parent field.">parent</a>().primeField();</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ae73b354cb047113ff835306c49dac752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt;T&gt; <a class="el" href="classFAAST_1_1FieldElement.html">FAAST::FieldElement</a>&lt; T &gt;::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1Field.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classFAAST_1_1NotASubFieldException.html">NotASubFieldException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trace over the field <em>F</em>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotASubFieldException.html" title="The field is not a subfield of the given field.">NotASubFieldException</a></td><td>If this element does not belong to an overfield of <em>F</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="testIso_8c_09_09-example.html#a4">testIso.c++</a>.</dd>
</dl>
</div>
</div>
<h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a8578eb66961b7bbc23c9887eab174cea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void liftUp </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="classFAAST_1_1NotInSameFieldException.html">NotInSameFieldException</a>, <a class="el" href="classFAAST_1_1NoOverFieldException.html">NoOverFieldException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <em>v</em> from the bivariate representation over the immediate subfield in the primitive tower (the stem) to the internal (univariate) representation. </p>
<p>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of the elements of <em>v</em> is the prime field, then <em>e</em> is the element whose univariate representation has <em>v</em> as cofficients. Otherwise let </p>
<div class="fragment"><div class="line">x = v[0].parent().primitiveElement();</div>
</div><!-- fragment --><p> This method stores in <em>e</em> an element of <a class="el" href="classFAAST_1_1Field.html#a872ca3872d812bccfe48dd94b2e3348e"><code>e.parent()<code></code>.overField()</code> </a> such that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \mathtt{e} = \mathtt{v[0]} + \mathtt{v[1]}*\mathtt{x} + ... + \mathtt{v[p-1]}*\mathtt{x}^{p-1} \mathrm{,} \end{equation}" src="form_3.png"/>
</p>
<p> If <em>v</em> is too short, it is filled with zeros. If <em>v</em> is too long, the unnecessary elements are ignored.</p>
<p>Let <b>K</b> be the field in the primitive tower (the stem) isomorphic to the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of the elements of <em>v</em>, this corresponds to convert <em>v</em> from the multivariate representation as an element of <b>K</b>[<em>x</em>] to the internal (univariate) representation. This routine implements the algorithm <code>LiftUp</code> of [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 4.4].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A vector of elements all in the same field. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e</td><td>An element satisfying condition (2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NotInSameFieldException.html" title="The two elements do not belong to the same field.">NotInSameFieldException</a></td><td>If the elements of <em>v</em> do not all have the same <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NoOverFieldException.html" title="No overfield is known for the given field.">NoOverFieldException</a></td><td>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of the elements of <em>v</em> has no <a class="el" href="classFAAST_1_1Field.html#a872ca3872d812bccfe48dd94b2e3348e">overfield</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The result always lies in the primitive tower (the stem), even if the elements of <em>v</em> do not. </dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of the elements of <em>v</em> is in the primitive tower (the stem), this is equivalent to <div class="fragment"><div class="line">v[0].parent().overField().toUnivariate(e, v);</div>
</div><!-- fragment --> and this latter form should be preferred for the sake of clarity. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1Field.html#a6020e3f1cf26bbf536152ff85beb37b6" title="Convert the multivariate representation of v to the univariate representation of this field...">Field::toUnivariate()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acc1e83d603a387d3a875f52ca2842e0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pushDown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classFAAST_1_1FieldElement.html">FieldElement</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="classFAAST_1_1NoSubFieldException.html">NoSubFieldException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <em>e</em> from the internal (univariate) representation to the bivariate representation over the immediate subfield in the primitive tower (the stem). </p>
<p>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of <em>e</em> is the base field of an Artin-Schreier tower, then <em>v</em> is filled with the coefficients in F<sub>p</sub> of its univariate representation. Otherwise let </p>
<div class="fragment"><div class="line">x = e.parent().primitiveElement();</div>
</div><!-- fragment --><p> This method fills the vector <em>v</em> with <a class="el" href="classFAAST_1_1Field.html#a04c4d0dfc9ceb5b7436d527bad8c9d5b">p</a> elements of <a class="el" href="classFAAST_1_1Field.html#a2f9151b6ebdf59478bb8a840a3c5386a"><code>e.parent()<code></code>.subField()</code> </a> such that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \mathtt{e} = \mathtt{v[0]} + \mathtt{v[1]}*\mathtt{x} + ... + \mathtt{v[p-1]}*\mathtt{x}^{p-1} \mathrm{.} \end{equation}" src="form_2.png"/>
</p>
<p>Let <b>K</b> be the field in the primitive tower (the stem) isomorphic to <a class="el" href="classFAAST_1_1Field.html#a2f9151b6ebdf59478bb8a840a3c5386a"><code>e.parent()<code></code>.subField()</code> </a>, this corresponds to convert <em>e</em> from its internal (univariate) representation to the bivariate representation as an element of <b>K</b>[<em>x</em>]. This routine implements the algorithm <code>PushDown</code> of [<a class="el" href="References.html#ISSAC">DFS '09</a>, Section 4.2].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>An element of any field. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>A vector of elements of <a class="el" href="classFAAST_1_1Field.html#aea87cd55abed5aaf90f62070ff7f012e"><code>e.parent()<code></code>.stemField()</code> </a> that satisfies condition (1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classFAAST_1_1NoSubFieldException.html" title="No subfield is known for the given field.">NoSubFieldException</a></td><td>If F<sub>p</sub> is the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of <em>e</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The result always lies in the primitive tower (the stem), even if <em>e</em> does not. </dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If the <a class="el" href="classFAAST_1_1FieldElement.html#a78120b7dff3255ead926f22a466fc438">parent field</a> of <em>e</em> is in the primitive tower (the stem), this is equivalent to <div class="fragment"><div class="line">e.parent().subField().toBivariate(e, v);</div>
</div><!-- fragment --> and this latter form should be preferred for the sake of clarity. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFAAST_1_1Field.html#ac35d44bfcaff36077b66015bfbea15aa" title="Convert the univariate representation of e to the multivariate representation over this field...">Field::toBivariate()</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 3 2013 20:49:49 for FAAST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
