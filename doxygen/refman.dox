namespace FAAST {
/**
	\page Refman Reference Manual
	
	FAAST offers an intuitive object-oriented interface to handle finite fields and
	their extensions. The three main types you will use are Field, FieldElement and
	FieldPolynomial, which are described in the section \ref Refman_Field.
	
	FAAST adds some genericity on top of the traditional \NTL architecture, one of
	its most prominent features is the mechanism of
	\ref Refman_Infrastructure which uses C++ templates to let you choose statically
	(at compile-time) which set of \NTL algorithms use.
	
	All in all, the goal of FAAST is to represent \ref Field_lattices and give
	algorithms to work into them. For the moment FAAST is limited to some special
	types of lattices arising from Artin-Schreier towers. See \ref Field_lattices
	for more details.
	
	\section Refman_Field Finite Field Arithmetics
	\copydoc Fields
	
	See the module \ref Fields for the list of methods and
	functions.

	\section Refman_Infrastructure Infrastructures
	\copydoc Infrastructures
	
	See the module \ref Infrastructures for more details.
	
	\section Field_lattices Lattices of fields
	The most exciting feature of FAAST is its ability to deal with field extension
	and keep track of morphisms. This ability is limited to Artin-Schreier towers
	as described in [\ref ISSAC "DFS&nbsp;'09"] and
	[\ref Cou00 "Couveignes&nbsp;'00"] and gives rise to lattices of a special
	form; we call them \e stem \e lattices.
	
	For the rest of this section \a p will be the characteristic of our
	fields. Remind that an Artin-Schreier extension is a field extension of degree
	\a p generated by an irreducible polynomial of the form
	\f[ X^p - X - a\mathrm{.} \f]
	
	The simplest lattice is the lattice formed by a single field. Finite fields
	of arbitrary cardinality can be built through the static instantiators
	Field::createField(). Suppose you build the field with \a p elements
	F<sub>p</sub> then the resulting lattice looks like
	\f[F_p\f]
	
	When you build non-prime fields, the prime subfield is automatically
	constructed. Suppose you build a field named <b>K</b><sub>0</sub>,
	then the resulting lattice looks like
	\f[\xymatrix{
		\mathbf{K}_0 \ar@{-}[d]\\
		F_p
	}\f]
	
	Now, to add fields to a lattice there is two methods, namely
	Field::ArtinSchreierExtension() const
	and Field::ArtinSchreierExtension(const FieldElement&) const. Both
	create an Artin-Schreier extension, but they differ in the way the extension
	is created. The former method chooses a default irreducible
	Artin-Schreier polynomial such
	that the generated Artin-Schreier extension is \a primitive in the
	sense of [\ref ISSAC "DFS&nbsp;'09", Section 3]. The resulting lattice is then
	\f[\xymatrix{
		\mathbf{K}_1\ar@{-}[d]^p\\
		\mathbf{K}_0 \ar@{-}[d]\\
		F_p
	}\f]
	The latter method constructs the splitting fields of the polynomial
	\f$ X^p - X - \mathtt{e} \f$
	where \c e is the FieldElement given as a parameter. Assuming that
	the polynomial is irreducible, it constructs a primitive extension using
	Field::ArtinSchreierExtension() const and then uses the isomorphism
	algorithm of [\ref Cou00 "Couveignes&nbsp;'00"] to establish an isomorphism
	between the primitive field and the splitting field. So for example a
	call to
	\code
	K0.ArtinSchreierExtension(e);
	\endcode
	would generate a lattice 
	\f[\xymatrix{
		\mathbf{K}_1\ar@{-}[d]^p & \mathbf{L}_1\ar@{~}[l]\\
		\mathbf{K}_0 \ar@{-}[d]\\
		F_p
	}\f]
	where <b>K</b><sub>1</sub> is the primitive extension and <b>U</b><sub>1</sub>
	is the field generated by \f$X^p - X - \mathtt{e}\f$.
	
	All the objects of type Field are persistent: once they are created
	they are never destroyed. So, even if you don't hold a reference to
	<b>K</b><sub>1</sub>, another call to
	\code
	K0.ArtinSchreierExtension(e2);
	\endcode
	will not create a new primitive field, it will use <b>K</b><sub>1</sub>
	instead. The resulting lattice would be 
	\f[\xymatrix{
		\mathbf{M}_1\ar@{~}[r] & \mathbf{K}_1\ar@{-}[d]^p & \mathbf{L}_1\ar@{~}[l]\\
		& \mathbf{K}_0 \ar@{-}[d]\\
		& F_p
	}\f]

	By repeatedly mixing calls to the two methods, one ends up with lattices of
	the form
	\f[\xymatrix{
		\mathbf{W}_n\ar@{~}[r] & \mathbf{K}_n\ar@{--}[dd] & \mathbf{Z}_n\ar@{~}[l]\\
		\\
		\mathbf{U}_2\ar@{~}[r] & \mathbf{K}_2\ar@{-}[d]^p & \mathbf{V}_2\ar@{~}[l]\\
		\mathbf{M}_1\ar@{~}[r] & \mathbf{K}_1\ar@{-}[d]^p & \mathbf{L}_1\ar@{~}[l]\\
		                       & \mathbf{K}_0 \ar@{-}[d]\\
		                       & F_p
	}\f]
	
	Now the reason why we call this a \e stem \e lattice should be clear. In the
	middle there's the \e primitive \e tower (<b>K</b><sub>0</sub>,
	<b>K</b><sub>1</sub>, ..., <b>K</b><sub>n</sub>), in the sense
	of [\ref ISSAC "DFS&nbsp;'09", Section 3], which we call \e the \e stem.
	The stem is organized in levels, each level being an extension of degree
	\a p over the lower one (with the only possible exception of the extension
	<b>K</b><sub>0</sub>/F<sub>p</sub>). At each level, a set of fields all
	isomorphic to that level forms the \a spurs.
	
	The methods Field::subField(), Field::overField(), Field::baseField(),
	Field::primeField() and Field::stemField() let you
	navigate field lattices.
	
	Coercion operators (see FieldElement and FieldPolynomial) let you move
	elements from one field to the other, provided that the element belongs
	to both fields. So for example you can move elements from <b>K</b><sub>0</sub>
	or <b>M</b><sub>1</sub> to <b>L</b><sub>1</sub>, but it will not always
	be possible to move an element from <b>K</b><sub>2</sub> to <b>K</b><sub>1</sub>.
	For example, coercion from <b>K</b><sub>0</sub> to <b>K</b><sub>1</sub> is
	as easy as
	\code
	e0 = K0.random();
	e1 = e0 >> K1;
	\endcode
	In case a coercion is not possible, an IllegalCoercionException is issued.
	
	Another way of moving around in field lattices is to use the vector space
	morphisms between the levels of the lattice. The functions pushDown() and
	liftUp() let you express the morphism between two adjacent levels of the
	stem, while Field::toBivariate() and Field::toUnivariate() let you express
	the morphisms between to arbitrary spurs in two adjacent levels. Notice
	that there is no need to know what the order of the calls to
	Field::ArtinSchreierExtension() was in order to apply these methods: any
	field of a level can be considered as an Artin-Schreier extension over any
	other field in the lower level.
	 
	\section Refman_Exception Exceptions
	See the \ref Exceptions module for a list of all the exceptions
	thrown by methods and functions of this library.
	
	\if DEV
	\section Refman_Other Other Modules
	If you are interested in the internals of FAAST, you might want to have
	a look at the \ref NTLhacks and \ref Utilities modules.
	\endif
*/
}