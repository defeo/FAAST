namespace AS {
/****************** Minimal polynomials ******************/
	/* The minimal polynomial over the field F */
	template<class T> FieldPolynomial<T>
	FieldElement<T>::minimalPolynomial(const Field<T>& F)
	const throw(NotASubFieldException) {
		if (*(F.stem) == *(parent_field.stem)) {
			FieldPolynomial<T> minPol = -(*this);
			minPol.setCoeff(1);
			minPol >>= F;
			return minPol;
		} else if (*(F.stem) == parent_field.primeField()) {
			parent_field.switchContext();
			GFpX minpol;
			MinPolyMod(minpol, rep(repExt), GFpE::modulus());
			return F.fromInfrastructure(minpol);
		} else {
			vector<FieldPolynomial<T> > minpols;
			minimalPolynomials(F, minpols);
			return minpols[0];
		}
	}

	/* All the minimal polynomials up to the field F.
	 *		res = minimalPolynomials(F);
	 * res[0] contains minimalPolynomials(F), res[1] contains
	 * minimalPolynomials(F.overfield) and so on.
	 */
	template <class T> void FieldElement<T>::minimalPolynomials(
	const Field<T>& F, vector<FieldPolynomial<T> >& res)
	const throw(NotASubFieldException) {
		Field<T>* G = parent_field->stem;
		if (!F.isSubField(*G)) throw NotASubFieldException();
		
		long levels = G->height - F.height + 1;
		long prime = 0;
		if (F.stem->overfield->isBaseField() && !G->isPrimeField())
			prime = 1;
		res.resize(levels+prime);
		// minimal polynomial is  (X-this)
		levels--;
		res[levels + prime] = -(*this);
		res[levels + prime].setCoeff(1);
		res[levels + prime] >>= *G;
		// first loop
		// go down as long as this is a member of the subfield
		try {
			while (!G->isBaseField() && *G != *(F.stem)) {
				res[levels + prime - 1] =
					res[levels + prime] >> *(G->subfield);
				levels--;
				G = G->subfield;
			}
		} catch (IllegalCoercionException e) {}
		// second loop
		// go down by galois conjugation
		while (!G->isBaseField() && *G != *(F.stem)) {
			FieldPolynomial<T> tmp = res[levels + prime];
			res[levels + prime - 1] = res[levels + prime];
			for (BigInt i = 1 ; i < G->p ; i++) {
				tmp.frobenius(power_long(G->p, G->height - 1)*G->d);
				res[levels + prime -1] *= tmp;
			}
			res[levels + prime - 1] >>= *(G->subfield);
			G = G->subfield;
			levels--;
		}
		// last level: prime field or move out of the stem
		if (prime > 0) {
			res[0] = minimalPolynomial(F);
		} else {
			res[0] >>= F;
		}
	}

	/* All the affine minimal polynomials up to the field F. If
	 * called this way :
	 *		affineMinimalPolynomials(F, a, res);
	 * res[0] will contain affineMinimalPolynomials(F,a), res[1]
	 * will contain affineMinimalPolynomials(F.overfield,a) and so on.
	 * throws: NotASubFieldException if F is not a subfield of this.parent
	 * throws: NoSuchPolynomialException if a is not in the field
	 * 			generated by this
	 * throws: NotSupportedException if F is not part of an Artin-Schreier tower
	 */
	template <class T> void affineMinimalPolynomials(const Field<T>& F,
	const FieldElement<T>& a, vector<FieldPolynomial<T> >& v)
	const throw(NotASubFieldException, NoSuchPolynomialException) {
		Field<T>* G = parent_field->stem;
		if (!F.isSubField(*G)) throw NotASubFieldException();
		
		if (F.isPrimeField() && !F.isBaseField) throw NotSupportedException();
		
		if (!a.parent_field.isSubField(*G) throw NoSuchPolynomialException();
		long levels = G->height - F.height + 1;
		res.resize(levels);
		// minimal polynomial is a
		levels--;
		res[levels] = a;
		res[levels] >>= *G;

		// first loop :
		// go down as long as this is a member of the subfield
		FieldElement<T> tmp = *this;
		try {
			while (*G != *(F.stem)) {
				tmp >>= *(G->subfield);
				try {
					res[levels - 1] = res[levels] >> *(G->subfield);
				} catch (IllegalCoercionException e) {
					throw NoSuchPolynomialException();
				}
				levels--;
				G = G->subfield;
			}
		} catch (IllegalCoercionException e) {}

		// get the list of minimal polynomials of this
		vector<FieldPolynomial<T> > minpols;
		tmp.minimalPolynomials(*(F.stem), minpols);
		
		// second loop :
		// go down as long as a is a member of the subfield
		try {
			while (*G != *(F.stem)) {
			}
		} catch (IllegalCoercionException e) {}
		
		
		// third loop : interpolation
		while (*G != *(F.stem)) {
		}
	}
		
}
