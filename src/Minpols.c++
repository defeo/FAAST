namespace AS {
/****************** Minimal polynomials ******************/
	/* The minimal polynomial over the field F */
	template<class T> FieldPolynomial<T>
	FieldElement<T>::minimalPolynomial(const Field<T>& F)
	const throw(NotASubFieldException) {
		if (*(F.stem) == *(parent_field.stem)) {
			FieldPolynomial<T> minPol = -(*this);
			minPol.setCoeff(1);
			minPol >>= F;
			return minPol;
		} else if (*(F.stem) == parent_field.primeField()) {
			parent_field.switchContext();
			GFpX minpol;
			MinPolyMod(minpol, rep(repExt), GFpE::modulus());
			return F.fromInfrastructure(minpol);
		} else {
			vector<FieldPolynomial<T> > minpols;
			minimalPolynomials(F, minpols);
			return minpols[0];
		}
	}

	/* All the minimal polynomials up to the field F.
	 *		res = minimalPolynomials(F);
	 * res[0] contains minimalPolynomials(F), res[1] contains
	 * minimalPolynomials(F.overfield) and so on.
	 */
	template <class T> void FieldElement<T>::minimalPolynomials(
	const Field<T>& F, vector<FieldPolynomial<T> >& res)
	const throw(NotASubFieldException) {
		Field<T>* G = parent_field->stem;
		if (!F.isSubFieldOf(*G)) throw NotASubFieldException();

		long levels = G->height - F.height + 1;
		long prime = 0;
		if (F.stem->overfield->isBaseField() && !G->isPrimeField())
			prime = 1;
		res.resize(levels+prime);
		// minimal polynomial is  (X-this)
		levels--;
		res[levels + prime] = -(*this);
		res[levels + prime].setCoeff(1);
		res[levels + prime] >>= *G;
		// first loop
		// go down as long as this is a member of the subfield
		try {
			while (!G->isBaseField() && *G != *(F.stem)) {
				res[levels + prime - 1] =
					res[levels + prime] >> *(G->subfield);
				levels--;
				G = G->subfield;
			}
		} catch (IllegalCoercionException e) {}
		// second loop
		// go down by galois conjugation
		while (!G->isBaseField() && *G != *(F.stem)) {
			FieldPolynomial<T> tmp = res[levels + prime];
			res[levels + prime - 1] = res[levels + prime];
			for (BigInt i = 1 ; i < G->p ; i++) {
				tmp.frobenius(power_long(G->p, G->height - 1)*G->d);
				res[levels + prime -1] *= tmp;
			}
			res[levels + prime - 1] >>= *(G->subfield);
			G = G->subfield;
			levels--;
		}
		// last level: prime field or move out of the stem
		if (prime > 0) {
			res[0] = minimalPolynomial(F);
		} else {
			res[0] >>= F;
		}
	}

	/* The a-affine minimal polynomial over the field F,
	 * That is the minimum degree polynomial P of F[X] such that
	 * 		P(this) = a.
	 * The optional parameter minpols must contain either the result of
	 * this.minimalPolynomials(F,v), or must be an empty vector, in which
	 * case it is filled with the result of minimalPolynomials(F,v).
	 *
	 * throws: NotASubFieldException if F is not a subfield of this.parent
	 * throws: NoSuchPolynomialException if a is not in the field
	 * 			generated by this
	 * throws: NotSupportedException if F is not part of an Artin-Schreier tower
	 */
	FieldPolynomial<T> affineMinimalPolynomial(
	const Field<T>& F, const FieldElement<T>& a,
	vector<FieldPolynomial<T> >& minpols)
	const throw(NotASubFieldException, NoSuchPolynomialException,
	NotSupportedException, BadParametersException) {
		Field<T>* G = parent_field->stem;
		Field<T>& H = *(a.parent_field->stem);
		if (!F.isSubFieldOF(*G)) throw NotASubFieldException();

		if (F.isPrimeField() && !F.isBaseField) throw NotSupportedException();

		if (!H.isSubFieldOf(*G)) throw NoSuchPolynomialException();
		// minimal polynomial is a
		FieldPolynomial<T> res = a;
		//TODO Ã§a c'est stupide !
		res >>= H;

		// first loop :
		// go down as long as this is a member of the subfield
		FieldElement<T> tmp = *this;
		try {
			while (*G != *(F.stem)) {
				tmp >>= *(G->subfield);
				try {
					if (H.isOverFieldOf(*G)) res >> *(G->subfield);
				} catch (IllegalCoercionException e) {
					throw NoSuchPolynomialException();
				}
				levels--;
				G = G->subfield;
			}
		} catch (IllegalCoercionException e) {}

		// get the list of minimal polynomials of this
		if (minpols.size() == 0)
			tmp.minimalPolynomials(*F, minpols);
		else if (minpols.size() < G->height - F->height + 1)
			throw BadParametersException("minpols too small.");

		// second loop :
		// go down as long as a is a member of the subfield
		try {
			while (*G != *(F.stem)) {
			}
		} catch (IllegalCoercionException e) {}


		// third loop : interpolation
		while (*G != *(F.stem)) {
		}
	}

	/* Returns P(this).
	 *
	 * The optional parameter minpols must contain either the result of
	 * this.minimalPolynomials(P.parent,v), or must be an empty vector,
	 * in which case it is filled with the result of
	 * minimalPolynomials(P.parent,v).
	 *
	 * throws : IllegalCoercionException if this cannot be coerced to P.parent
	 * 			nor can P be coerced to this.parent
	 */
	template <class T> FieldElement<T>
	FieldElement::evaluate(const FieldPolynomial<T>& P,
	vector<FieldPolynomial<T> >& minpols)
	const throw(IllegalCoercionException, BadParametersException) {
		Field<T>* G = parent_field->stem;
		Field<T>* F = P.parent_field;
		// first case : this must go up
		if (F->isOverFieldOf(*G)) {
			FieldElement<T> x = *this >> *F;
			// Horner rule
			FieldElement<T> res, coeff;
			P.getCoeff(res, P.degree());
			for (long i = P.degree()-1 ; i >= 0 ; i++) {
				res *= x;
				P.getCoeff(coeff, i);
				res += coeff;
			}
			return res;
		}
		// second case : this must go down
		else if (F->isSubFieldOf(*G)) {
			// first loop :
			// go down as long as this is a member of the subfield
			FieldElement<T> tmp = *this;
			try {
				while (*G != *(F->stem)) {
					tmp >>= *(G->subfield);
					G = G->subfield;
				}
			} catch (IllegalCoercionException e) {}

			// get the minimal polynomials if needed
			if (minpols.size() == 0)
				tmp.minimalPolynomials(*F, minpols);
			else if (minpols.size() < G->height - F->height + 1)
				throw BadParametersException("minpols too small.");

			// second loop :
			// go up reducing by the minimal polynomials
			FieldPolynomial<T> reduced = P;
			long i = 0;
			try {
				F = F->stem;
				while (*F != *G) {
					reduced %= minpols[i];
					reduced >>= F->overField();
					F = F->overfield;
					i++;
				}
			} catch (IllegalCoercionException e) {
				throw BadParametersException("Bad polynomials in minpols.");
			}
			// Horner rule
			FieldElement<T> res = tmp.evaluate(reduced);
			// move back to the original field
			res >>= *parent_field;
			return res;
		}
		// otherwise throw exception
		else throw IllegalCoercionException();
	}

}
